use theon::adjunct::{Converged, Fold, Map, ZipMap};
use theon::query::{Aabb, Intersection};
use theon::space::{EuclideanSpace, FiniteDimensional, Scalar, Vector};
use typenum::Unsigned;

use crate::partition::{Partition, Subdivide};
use crate::{Half, Spatial};

pub struct NCube<S>
where
    S: EuclideanSpace,
{
    origin: S,
    width: Scalar<S>,
}

impl<S> NCube<S>
where
    S: EuclideanSpace,
{
    pub fn center(&self) -> S
    where
        Vector<S>: Converged,
    {
        self.origin + Vector::<S>::converged(self.width.half())
    }

    pub fn aabb(&self) -> Aabb<S>
    where
        Vector<S>: Converged,
    {
        Aabb {
            origin: self.origin,
            extent: Converged::converged(self.width),
        }
    }
}

impl<S> Partition for NCube<S>
where
    S: EuclideanSpace + FiniteDimensional + Map<Output = S> + ZipMap<usize>,
    <S as ZipMap<usize>>::Output: Fold,
    Aabb<S>: Intersection<S>,
    Vector<S>: Converged,
{
    fn contains(&self, point: &Self::Position) -> bool {
        self.aabb().intersection(point).is_some()
    }

    fn index_unchecked(&self, point: &Self::Position) -> usize {
        let mut dimension = 0usize;
        point
            .zip_map(self.center(), |x, c| {
                let index = if x < c { 0 } else { 1 << dimension };
                dimension += 1;
                index
            })
            .sum()
    }
}

impl<S> Spatial for NCube<S>
where
    S: EuclideanSpace + FiniteDimensional,
{
    type Position = S;
}

impl<S> Subdivide for NCube<S>
where
    S: Map<Output = S> + EuclideanSpace + FiniteDimensional,
{
    // TODO: Is it possible to constrain `FiniteDimensional` and specify an
    //       `ArrayVec` of the correct capacity? Maybe the implementation of
    //       `subdivide` could be factored out in a generic way and its output
    //       iterator could be collected within `impl` blocks generated by a
    //       macro.
    type Output = Vec<Self>;

    fn subdivide(&self) -> Self::Output {
        let width = self.width.half();
        (0i32..2i32.pow(<S as FiniteDimensional>::N::U32))
            .map(|n| {
                let origin = {
                    let mut dimension = 0usize;
                    self.origin.map(|x| {
                        let x = match (n / (2i32.pow(dimension as u32))) % 2i32 {
                            0 => x,
                            1 => x + width,
                            _ => unreachable!(),
                        };
                        dimension += 1;
                        x
                    })
                };
                NCube { origin, width }
            })
            .collect()
    }
}

#[cfg(test)]
mod tests {
    use theon::integration::nalgebra;

    use nalgebra::{Point2, Point3};
    use theon::space::EuclideanSpace;

    use crate::partition::{NCube, Partition, Subdivide};

    type E2 = Point2<f64>;
    type E3 = Point3<f64>;

    #[test]
    fn partition_e2() {
        let cube = NCube::<E2> {
            origin: EuclideanSpace::origin(),
            width: 8.0,
        };
        assert_eq!(0, cube.index_unchecked(&EuclideanSpace::origin()));
        assert_eq!(3, cube.index_unchecked(&EuclideanSpace::from_xy(4.0, 4.0)));
        assert_eq!(None, cube.index(&EuclideanSpace::from_xy(-4.0, -4.0)));
        assert!(cube.contains(&EuclideanSpace::origin()));
        assert!(cube.contains(&EuclideanSpace::from_xy(4.0, 4.0)));
        assert!(!cube.contains(&EuclideanSpace::from_xy(-1.0, -1.0)));
    }

    #[test]
    fn subdivide_e2() {
        let cube = NCube::<E2> {
            origin: EuclideanSpace::origin(),
            width: 8.0,
        };
        let divisions = cube.subdivide();
        assert_eq!(4, divisions.len());
        assert!(divisions.iter().all(|cube| cube.width == 4.0));
    }

    #[test]
    fn subdivide_e3() {
        let cube = NCube::<E3> {
            origin: EuclideanSpace::origin(),
            width: 8.0,
        };
        let divisions = cube.subdivide();
        assert_eq!(8, divisions.len());
        assert!(divisions.iter().all(|cube| cube.width == 4.0));
    }
}
